{% extends 'base.html' %}
{% load static %}
{% block title %}–û–Ω–ª–∞–π–Ω —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—è{% endblock %}
{% block content %}
    {#    <script src="{% static 'js/hls.light.min.js' %}"></script>#}
    <section id="livecam_page">
        <div class="livecam_page">
            <div class="livecam_page-block">
                <p class="title_livecam">–ö–∞–º–µ—Ä–∞ –Ω–∞ –≤—Ö–æ–¥–Ω–æ–π –≥—Ä—É–ø–ø–µ</p>
                <video id="cam_entrance_video" class="livecam_video_block-video" muted playsinline controls></video>
            </div>
            <div class="livecam_page-block">
                <p class="title_livecam">–ö–∞–º–µ—Ä–∞ –Ω–∞ –≤—Ö–æ–¥–Ω–æ–π –≥—Ä—É–ø–ø–µ –∑–∞–¥–Ω–µ–≥–æ –¥–≤–æ—Ä–∞</p>
                <video id="cam_b_entrance_video" class="livecam_video_block-video" muted playsinline controls></video>
            </div>

            <div id="stream_status_overlay">
                <div class="status-indicator" id="status_cam_entrance">‚è≥ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...</div>
                <div class="status-indicator" id="status_cam_back_entrance">‚è≥ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...</div>
            </div>

        </div>
    </section>

    <style>
        #stream_status_overlay {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 9999;
            font-size: 14px;
            background-color: rgba(0,0,0,0.6);
            padding: 8px 12px;
            border-radius: 10px;
            color: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }
        .status-indicator {
            margin-bottom: 4px;
        }
    </style>

    <script>
        async function startWebRTC(videoElemId, cameraPath, retryCount = 0) {
            const video = document.getElementById(videoElemId);
            const statusElem = document.getElementById(`status_${cameraPath}`);

            if (!video || !statusElem) {
                console.error(`[${cameraPath}] Video or status element not found`);
                return;
            }

            const MAX_RETRIES = 5;
            const RETRY_DELAY_MS = 5000;
            let pc = null;
            let timeoutId = null;

            const updateStatus = (icon, text) => {
                statusElem.textContent = `${icon} ${text}`;
            };

            const reconnect = () => {
                updateStatus('üî¥', '–ü–æ—Ç–æ–∫ –ø–æ—Ç–µ—Ä—è–Ω. –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...');
                setTimeout(() => {
                    startWebRTC(videoElemId, cameraPath, retryCount + 1);
                }, RETRY_DELAY_MS);
            };

            try {
                updateStatus('‚è≥', '–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...');
                const webrtcConfResponse = await fetch('/get_webrtc_config/');
                if (!webrtcConfResponse.ok) {
                    throw new Error('Failed to fetch WebRTC config');
                }

                const webrtcConf = await webrtcConfResponse.json();
                pc = new RTCPeerConnection(webrtcConf);

                pc.addTransceiver('video', { direction: 'recvonly' });

                pc.ontrack = event => {
                    if (video.srcObject !== event.streams[0]) {
                        video.srcObject = event.streams[0];
                        updateStatus('üü¢', '–ü–æ—Ç–æ–∫ –∞–∫—Ç–∏–≤–µ–Ω');

                        if (timeoutId) clearTimeout(timeoutId);
                        timeoutId = setTimeout(() => {
                            updateStatus('üî¥', '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö. –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...');
                            pc.close();
                            reconnect();
                        }, 15000); // –µ—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –ø—Ä–∏—à–ª–æ 15 —Å–µ–∫ ‚Äî —Å—á–∏—Ç–∞–µ–º "–º–µ—Ä—Ç–≤—ã–º"
                    }
                };

                pc.onconnectionstatechange = () => {
                    const state = pc.connectionState;
                    if (state === 'disconnected' || state === 'failed' || state === 'closed') {
                        updateStatus('üî¥', '–ü–æ—Ç–µ—Ä—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è');
                        pc.close();
                        reconnect();
                    }
                };

                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                const response = await fetch(`/webrtc/${cameraPath}/whep`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/sdp",
                        "Accept": "application/sdp",
                    },
                    body: offer.sdp
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const answerSdp = await response.text();
                const answerDesc = new RTCSessionDescription({ type: "answer", sdp: answerSdp });
                await pc.setRemoteDescription(answerDesc);

            } catch (err) {
                updateStatus('‚ö†Ô∏è', '–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è');
                console.error(`[${cameraPath}] WebRTC error:`, err);
                if (retryCount < MAX_RETRIES) {
                    reconnect();
                }
            }
        }

        document.addEventListener("DOMContentLoaded", () => {
            startWebRTC("cam_entrance_video", "cam_entrance");
            startWebRTC("cam_b_entrance_video", "cam_back_entrance");
        });

    </script>

    {#    <script>#}
    {#        async function startWebRTC(videoElemId, cameraPath) {#}
    {#            const video = document.getElementById(videoElemId);#}
    {#            if (!video) {#}
    {#                console.error(`[${cameraPath}] Video element not found`);#}
    {#                return;#}
    {#            }#}
    {##}
    {#            const webrtcConfResponse = await fetch('/get_webrtc_config/');#}
    {#            if (!webrtcConfResponse.ok) {#}
    {#                console.error('Failed to fetch WebRTC config');#}
    {#                return;#}
    {#            }#}
    {#            const webrtcConf = await webrtcConfResponse.json();#}
    {#            const pc = new RTCPeerConnection(webrtcConf);#}
    {##}
    {#            pc.addTransceiver('video', { direction: 'recvonly' });#}
    {#            pc.ontrack = event => {#}
    {#                if (video.srcObject !== event.streams[0]) {#}
    {#                    video.srcObject = event.streams[0];#}
    {#                    // autoplay stream video#}
    {#video.play().catch(e => console.warn(`[${cameraPath}] Video play error:`, e));#}
    {#                }#}
    {#            };#}
    {##}
    {#            try {#}
    {#                const offer = await pc.createOffer();#}
    {#                await pc.setLocalDescription(offer);#}
    {#                const response = await fetch(`/webrtc/${cameraPath}/whep`, {#}
    {#                    method: "POST",#}
    {#                    headers: {#}
    {#                        "Content-Type": "application/sdp",#}
    {#                        "Accept": "application/sdp",#}
    {#                    },#}
    {#                    body: offer.sdp#}
    {#                });#}
    {##}
    {#                if (!response.ok) {#}
    {#                    const text = await response.text();#}
    {#                    throw new Error(`HTTP error! status: ${response.status}, body: ${text}`);#}
    {#                }#}
    {##}
    {#                const answerSdp = await response.text();#}
    {#                const answerDesc = new RTCSessionDescription({ type: "answer", sdp: answerSdp });#}
    {#                await pc.setRemoteDescription(answerDesc);#}
    {##}
    {#            } catch (err) {#}
    {#                console.error(`WebRTC error for ${cameraPath}:`, err);#}
    {#            }#}
    {#        }#}
    {##}
    {#        document.addEventListener("DOMContentLoaded", () => {#}
    {#            startWebRTC("cam_entrance_video", "cam_entrance");#}
    {#            startWebRTC("cam_b_entrance_video", "cam_back_entrance");#}
    {#        });#}
    {#    </script>#}

{% endblock %}