{% extends 'base.html' %}
{% load static %}
{% block title %}–û–Ω–ª–∞–π–Ω —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—è{% endblock %}
{% block content %}
    {#    <script src="{% static 'js/hls.light.min.js' %}"></script>#}
    <section id="livecam_page">
        <div class="livecam_page">
            <div class="livecam_page-block">
                <p class="title_livecam">–ö–∞–º–µ—Ä–∞ –Ω–∞ –≤—Ö–æ–¥–Ω–æ–π –≥—Ä—É–ø–ø–µ</p>
                <video id="cam_entrance_video" class="livecam_video_block-video" muted playsinline controls></video>

                <div class="stream-status" id="status_cam_entrance">‚è≥ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...</div>

            </div>
            <div class="livecam_page-block">
                <p class="title_livecam">–ö–∞–º–µ—Ä–∞ –Ω–∞ –≤—Ö–æ–¥–Ω–æ–π –≥—Ä—É–ø–ø–µ –∑–∞–¥–Ω–µ–≥–æ –¥–≤–æ—Ä–∞</p>
                <video id="cam_b_entrance_video" class="livecam_video_block-video" muted playsinline controls></video>

                <div class="stream-status" id="status_cam_back_entrance">‚è≥ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...</div>

            </div>


        </div>
    </section>

    <style>
        .stream-status {
            font-size: 14px;
            margin-top: 4px;
            color: #555;
        }
    </style>

    <script>
        async function startWebRTC(videoElemId, cameraPath, retryCount = 0) {
            const video = document.getElementById(videoElemId);
            const statusElem = document.getElementById(`status_${cameraPath}`);

            if (!video || !statusElem) {
                console.error(`[${cameraPath}] Video or status element not found`);
                return;
            }

            const MAX_RETRIES = 5;
            const RETRY_DELAY_MS = 5000;
            let pc = null;
            let receivedStream = false;

            const updateStatus = (icon, text) => {
                statusElem.textContent = `${icon} ${text}`;
            };

            const reconnect = () => {
                updateStatus('üî¥', '–ü–æ—Ç–æ–∫ –ø–æ—Ç–µ—Ä—è–Ω. –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...');
                setTimeout(() => {
                    startWebRTC(videoElemId, cameraPath, retryCount + 1);
                }, RETRY_DELAY_MS);
            };

            try {
                updateStatus('‚è≥', '–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...');
                const webrtcConfResponse = await fetch('/get_webrtc_config/');
                if (!webrtcConfResponse.ok) throw new Error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ WebRTC');

                const webrtcConf = await webrtcConfResponse.json();
                pc = new RTCPeerConnection(webrtcConf);

                pc.addTransceiver('video', { direction: 'recvonly' });

                // ‚è∞ –¢–∞–π–º–µ—Ä: –µ—Å–ª–∏ —á–µ—Ä–µ–∑ 10 —Å–µ–∫ –Ω–µ—Ç –ø–æ—Ç–æ–∫–∞ ‚Äî —Å—á–∏—Ç–∞–µ–º –æ—à–∏–±–∫–æ–π
                const timeout = setTimeout(() => {
                    if (!receivedStream) {
                        updateStatus('üî¥', '–ù–µ—Ç –ø–æ—Ç–æ–∫–∞. –ü–æ–≤—Ç–æ—Ä...');
                        pc.close();
                        reconnect();
                    }
                }, 10000);

                pc.ontrack = event => {
                    if (video.srcObject !== event.streams[0]) {
                        video.srcObject = event.streams[0];
                        receivedStream = true;
                        clearTimeout(timeout);
                        updateStatus('üü¢', '–ü–æ—Ç–æ–∫ –∞–∫—Ç–∏–≤–µ–Ω');
                    }
                };

                pc.onconnectionstatechange = () => {
                    const state = pc.connectionState;
                    if (['disconnected', 'failed', 'closed'].includes(state)) {
                        updateStatus('üî¥', '–ü–æ—Ç–µ—Ä—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è');
                        pc.close();
                        reconnect();
                    }
                };

                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                const response = await fetch(`/webrtc/${cameraPath}/whep`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/sdp",
                        "Accept": "application/sdp",
                    },
                    body: offer.sdp
                });

                if (!response.ok) {
                    throw new Error(`WHEP –æ—Ç–≤–µ—Ç —Å –æ—à–∏–±–∫–æ–π: ${response.status}`);
                }

                const answerSdp = await response.text();
                const answerDesc = new RTCSessionDescription({ type: "answer", sdp: answerSdp });
                await pc.setRemoteDescription(answerDesc);

            } catch (err) {
                updateStatus('‚ö†Ô∏è', '–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è');
                console.error(`[${cameraPath}] WebRTC error:`, err);
                if (retryCount < MAX_RETRIES) {
                    reconnect();
                }
            }
        }

        document.addEventListener("DOMContentLoaded", () => {
            startWebRTC("cam_entrance_video", "cam_entrance");
            startWebRTC("cam_b_entrance_video", "cam_back_entrance");
        });
    </script>


    {#    <script>#}
    {#        async function startWebRTC(videoElemId, cameraPath) {#}
    {#            const video = document.getElementById(videoElemId);#}
    {#            if (!video) {#}
    {#                console.error(`[${cameraPath}] Video element not found`);#}
    {#                return;#}
    {#            }#}
    {##}
    {#            const webrtcConfResponse = await fetch('/get_webrtc_config/');#}
    {#            if (!webrtcConfResponse.ok) {#}
    {#                console.error('Failed to fetch WebRTC config');#}
    {#                return;#}
    {#            }#}
    {#            const webrtcConf = await webrtcConfResponse.json();#}
    {#            const pc = new RTCPeerConnection(webrtcConf);#}
    {##}
    {#            pc.addTransceiver('video', { direction: 'recvonly' });#}
    {#            pc.ontrack = event => {#}
    {#                if (video.srcObject !== event.streams[0]) {#}
    {#                    video.srcObject = event.streams[0];#}
    {#                    // autoplay stream video#}
    {#video.play().catch(e => console.warn(`[${cameraPath}] Video play error:`, e));#}
    {#                }#}
    {#            };#}
    {##}
    {#            try {#}
    {#                const offer = await pc.createOffer();#}
    {#                await pc.setLocalDescription(offer);#}
    {#                const response = await fetch(`/webrtc/${cameraPath}/whep`, {#}
    {#                    method: "POST",#}
    {#                    headers: {#}
    {#                        "Content-Type": "application/sdp",#}
    {#                        "Accept": "application/sdp",#}
    {#                    },#}
    {#                    body: offer.sdp#}
    {#                });#}
    {##}
    {#                if (!response.ok) {#}
    {#                    const text = await response.text();#}
    {#                    throw new Error(`HTTP error! status: ${response.status}, body: ${text}`);#}
    {#                }#}
    {##}
    {#                const answerSdp = await response.text();#}
    {#                const answerDesc = new RTCSessionDescription({ type: "answer", sdp: answerSdp });#}
    {#                await pc.setRemoteDescription(answerDesc);#}
    {##}
    {#            } catch (err) {#}
    {#                console.error(`WebRTC error for ${cameraPath}:`, err);#}
    {#            }#}
    {#        }#}
    {##}
    {#        document.addEventListener("DOMContentLoaded", () => {#}
    {#            startWebRTC("cam_entrance_video", "cam_entrance");#}
    {#            startWebRTC("cam_b_entrance_video", "cam_back_entrance");#}
    {#        });#}
    {#    </script>#}

{% endblock %}