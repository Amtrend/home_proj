{% extends 'base.html' %}
{% load static %}
{% block title %}–û–Ω–ª–∞–π–Ω —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—è{% endblock %}
{% block content %}
    {#    <script src="{% static 'js/hls.light.min.js' %}"></script>#}
    <section id="livecam_page">
        <div class="livecam_page">
            <div class="livecam_page-block">
                <p class="title_livecam">–ö–∞–º–µ—Ä–∞ –Ω–∞ –≤—Ö–æ–¥–Ω–æ–π –≥—Ä—É–ø–ø–µ</p>
                <video id="cam_entrance_video" class="livecam_video_block-video" muted playsinline controls></video>
                <div class="stream-status" id="status_cam_entrance">‚è≥ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...</div>
            </div>
            <div class="livecam_page-block">
                <p class="title_livecam">–ö–∞–º–µ—Ä–∞ –Ω–∞ –≤—Ö–æ–¥–Ω–æ–π –≥—Ä—É–ø–ø–µ –∑–∞–¥–Ω–µ–≥–æ –¥–≤–æ—Ä–∞</p>
                <video id="cam_b_entrance_video" class="livecam_video_block-video" muted playsinline controls></video>
                <div class="stream-status" id="status_cam_back_entrance">‚è≥ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...</div>
            </div>
            <div class="livecam_page-block">
                <p class="title_livecam">–ö–∞–º–µ—Ä–∞ –≤ —Å–ø–∞–ª—å–Ω–µ</p>
                <video id="cam_baby" class="livecam_video_block-video" playsinline controls></video>
                <div class="stream-status" id="status_cam_baby">‚è≥ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...</div>
            </div>
        </div>
    </section>

    <script>
        async function startWebRTC(videoElemId, cameraPath, withAudio = false, retryCount = 0) {
            const video = document.getElementById(videoElemId);
            const statusElem = document.getElementById(`status_${cameraPath}`);

            if (!video || !statusElem) {
                console.error(`[${cameraPath}] Video or status element not found`);
                return;
            }

            if (withAudio) {
                video.muted = false;
                video.volume = 0;
            } else {
                video.muted = true;
            }

            const MAX_RETRIES = 5;
            const RETRY_DELAY_MS = 5000;
            let pc = null;
            let receivedStream = false;

            const updateStatus = (icon, text) => {
                statusElem.textContent = `${icon} ${text}`;
            };

            const reconnect = () => {
                updateStatus('üî¥', '–ü–æ—Ç–æ–∫ –ø–æ—Ç–µ—Ä—è–Ω. –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...');
                setTimeout(() => {
                    startWebRTC(videoElemId, cameraPath, withAudio, retryCount + 1);
                }, RETRY_DELAY_MS);
            };

            try {
                updateStatus('‚è≥', '–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...');
                const webrtcConfResponse = await fetch('/get_webrtc_config/');
                if (!webrtcConfResponse.ok) throw new Error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ WebRTC');

                const webrtcConf = await webrtcConfResponse.json();
                pc = new RTCPeerConnection(webrtcConf);

                pc.addTransceiver('video', { direction: 'recvonly' });

                if (withAudio) {
                    pc.addTransceiver('audio', { direction: 'recvonly' });
                }

                const timeout = setTimeout(() => {
                    if (!receivedStream) {
                        updateStatus('üî¥', '–ù–µ—Ç –ø–æ—Ç–æ–∫–∞. –ü–æ–≤—Ç–æ—Ä...');
                        pc.close();
                        reconnect();
                    }
                }, 10000);

                pc.ontrack = event => {
                    if (video.srcObject !== event.streams[0]) {
                        video.srcObject = event.streams[0];
                        video.play().catch(e => console.warn(`[${cameraPath}] Video play error:`, e));
                        receivedStream = true;
                        clearTimeout(timeout);
                        updateStatus('üü¢', '–ü–æ—Ç–æ–∫ –∞–∫—Ç–∏–≤–µ–Ω');
                    }
                };

                pc.onconnectionstatechange = () => {
                    const state = pc.connectionState;
                    if (['disconnected', 'failed', 'closed'].includes(state)) {
                        updateStatus('üî¥', '–ü–æ—Ç–µ—Ä—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è');
                        pc.close();
                        reconnect();
                    }
                };

                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                const response = await fetch(`/webrtc/${cameraPath}/whep`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/sdp",
                        "Accept": "application/sdp",
                    },
                    body: offer.sdp
                });

                if (!response.ok) {
                    throw new Error(`WHEP –æ—Ç–≤–µ—Ç —Å –æ—à–∏–±–∫–æ–π: ${response.status}`);
                }

                const answerSdp = await response.text();
                const answerDesc = new RTCSessionDescription({ type: "answer", sdp: answerSdp });
                await pc.setRemoteDescription(answerDesc);

            } catch (err) {
                updateStatus('‚ö†Ô∏è', '–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è');
                console.error(`[${cameraPath}] WebRTC error:`, err);
                if (retryCount < MAX_RETRIES) {
                    reconnect();
                }
            }
        }

        document.addEventListener("DOMContentLoaded", () => {
            startWebRTC("cam_entrance_video", "cam_entrance", false);
            startWebRTC("cam_b_entrance_video", "cam_back_entrance", false);
            startWebRTC("cam_baby", "cam_baby", true);
        });
    </script>
{% endblock %}